        - module VectorSpaces
        - 
        - export VectorSpace, ZeroSpace, dim, span, span_adjoint, kernel, image, preimage
        - export rank
        - 
        - using LinearAlgebra
        - 
        - import Base: show, size, copy, adjoint, union, intersect, in, issubset, (==), (*), (\)
        - import Base: eltype
        - import LinearAlgebra: rank
        - 
        - struct VectorSpace{T<:Number,Q<:Union{QRPivoted{T},Nothing}}
        -     n::Int
        -     rank::Int
        -     first::Int
        -     qrf::Q
       32     VectorSpace{T}(n::Int, rank::Int, first::Int, qrf::Q) where {T,Q} = new{T,Q}(n, rank, first, qrf)
        - end
        - 
        - function show(io::IO, vs::VectorSpace)
        -     println(io, typeof(vs), " rank ", vs.rank, " dim ", vs.n)
        - end
        - 
        - """
        -     VectorSpace(A::Union{AbstractMatrix,AbstractVector})
        - 
        - Create VectorSpace as subspace spanned by the column vectors of A.
        - The base space has dimension of the number of rows of A.
        - The dimension of the subspace is the (numerical) rank of A.
        - """
       20 function VectorSpace(A::AbstractMatrix{T}) where {T<:Number}
       20     n, m = size(A)
       20     r = 0
       20     if m > 0
       26         tol = tolerance(A)
       13         qrf = qr(A, ColumnNorm())
       13         r = _rank(qrf, tol)
        -     end
       33     if r <= 0 || r >= n
       12         qrf = nothing
        -     end
       20     VectorSpace{T}(n, r, 1, qrf)
        - end
        - 
        - VectorSpace(B::AbstractVector{T}) where {T<:Number} = VectorSpace(reshape(B, size(B, 1), 1))
        - """
        -     ZeroSpace([T<:Number,] n) -> VectorSpace
        - 
        - Create zero space in base space of dimension `n`. Default type is Float64.
        - """
        4 ZeroSpace(::Type{T}, n::Int) where {T<:Number} = VectorSpace{T}(n, 0, 1, nothing)
        3 ZeroSpace(n::Int) = ZeroSpace(Float64, n)
        - 
        - """
        -     VectorSpace([T<:Number], n)
        - 
        - Create base space of dimension`n`. Default type is Float64.
        - """
        4 VectorSpace(::Type{T}, n::Int) where {T<:Number} = VectorSpace{T}(n, n, 1, nothing)
        3 VectorSpace(n::Int) = VectorSpace(Float64, n)
        - 
       49 size(vs::VectorSpace) = (vs.n, vs.rank)
        6 rank(vs::VectorSpace) = vs.rank
        6 dim(vs::VectorSpace) = vs.n
        2 eltype(::VectorSpace{T}) where T = T
        - 
        - copy(vs::VectorSpace{T}) where {T} =
        -     VectorSpace{T}(vs.n, vs.rank, vs.first, vs.qrf)
        - 
        - """
        -     adjoint(vs::VectorSpace) -> VectorSpace
        - 
        - Create VectorSpace representing the orthogonal complement of `vs`. May be written `vs'`.
        - """
        4 function adjoint(vs::VectorSpace{T}) where {T}
        4     n, r = size(vs)
        4     if vs.first == 1
        4         f = r + 1
        -     else
        0         f = 1
        -     end
        4     r = n - r
        4     VectorSpace{T}(n, r, f, vs.qrf)
        - end
        - 
        - """
        -     span(vs::VectorSpace) -> Matrix
        - 
        - Return unitary matrix containing basis vectors of `vs`.
        - """
       18 function span(vs::VectorSpace{T}) where {T}
       18     if 0 < vs.rank < vs.n
       14         r = _range1(vs)
       14         vs.qrf.Q[:, r]
        -     else
        4         Matrix{T}(I, vs.n, vs.rank)
        -     end
        - end
        - 
        - """
        -     span_adjoint(vs::VectorSpace) -> Matrix
        - 
        - Return unitary matrix containing basis vectors of orthogonal complement of `vs`.
        - Generally `span(vs') == span_adjoint(vs) is true`.
        - """
       10 function span_adjoint(vs::VectorSpace{T}) where {T}
       10     if 0 < vs.rank < vs.n
        5         r = _range2(vs)
        5         vs.qrf.Q[:, r]
        -     else
        5         Matrix{T}(I, vs.n, vs.n - vs.rank)
        -     end
        - end
        - 
       14 @inline function _range1(vs::VectorSpace)
       14     f = vs.first
       14     l = vs.rank + f - 1
       14     f:l
        - end
        - 
        5 @inline function _range2(vs::VectorSpace)
        5     n, r = size(vs)
        5     f = vs.first == 1 ? r + 1 : 1
        5     l = n - r + f - 1
        5     f:l
        - end
        - 
        - """
        -     *(A::AbstractMatrix, vs::VectorSpace) -> VectorSpace
        - 
        - Calculate the image of the vector space `vs` under matrix `A`.
        - Discard small column vectors in `A * span(vs)`.
        - Use `A * vs` rather than `VectorSpace(A * span(A))` for accuracy.
        - """
        1 function *(A::AbstractMatrix{T}, vs::VectorSpace{T}) where {T<:Number}
        1     n, m = size(A)
        1     nv, r = size(vs)
        1     m == nv || error("dimension mismatch")
        - 
        1     if r == 0
        0         ZeroSpace(T, n)
        1     elseif r == nv
        1         VectorSpace(A)
        -     else
        0         spana = A * span(vs)
        0         tol = tolerance(A)
        0         for k = 1:r
        0             if norm(spana[:, k], Inf) < tol
        0                 spana[:, k] = 0
        -             end
        0         end
        0         VectorSpace(spana)
        -     end
        - end
        - 
        - """
        -     \\(A::AbstractMatrix, vs::VectorSpace) -> VectorSpace
        - 
        - Calculate the preimage of the vector space `vs` under matrix `A`.
        - Discard small row vectors in `span(vs')' * A`.
        - Use `A \\ vs` rather than `VectorSpace(span(vs')'A)` for accuracy.
        - """
        1 function \(A::AbstractMatrix{T}, vs::VectorSpace{T}) where {T<:Number}
        1     n, m = size(A)
        1     nv, r = size(vs)
        1     n == nv || error("dimension mismatch")
        - 
        1     if r == nv
        0         VectorSpace(T, m)
        1     elseif r == 0
        1         kernel(A)
        -     else
        0         spana = span_adjoint(vs)'A
        0         tol = tolerance(A)
        0         for k = 1:nv-r
        0             if norm(spana[k, :], Inf) < tol
        0                 spana[k, :] .= 0
        -             end
        0         end
        0         kernel(spana)
        -     end
        - end
        - 
        - """
        -     image(A:AbstractMatrix[, vs::VectorSpace] [, k = 1]) -> VectorSpace
        - 
        - Create image of `vs` under `A^k`. If k ≠ 1 A must be square matrix.
        - If vs is not given, the usual image (range) of `A` is returned.
        - """
        6 image(A::AbstractArray{T}) where {T<:Number} = VectorSpace(A)
        - function image(A::AbstractArray{T}, k::Int) where {T<:Number}
        -     k == 1 ? VectorSpace(A) : image(A, VectorSpace(T, size(A, 2)), k)
        - end
        - 
        - function image(A::AbstractMatrix, vs::VectorSpace, k::Int=1)
        -     k ≥ 0 || error("exponent ≥ 0 required")
        -     n, m = size(A)
        -     na, ra = size(vs)
        -     n == m || k == 1 || error("exponent k ≠ 1 only for square matrix")
        -     na == m || error("matrix dimension 2 does not match source space dimension")
        - 
        -     va = vs
        -     if k > 0
        -         va = ra == m ? image(A) : A * va
        -         r = rank(va)
        -         while k > 1 && 0 < r < n
        -             vaa = A * va
        -             n = r
        -             r = rank(vaa)
        -             k -= 1
        -             if r < n
        -                 va = vaa
        -             end
        -         end
        -     end
        -     va
        - end
        - 
        - """
        -     kernel(A::AbstractArray) -> VectorSpace
        - 
        - Create VectorSpace representing the kernel or null-space of the mapping given by matrix `A`.
        - """
        7 kernel(A::AbstractArray) = VectorSpace(kernel_matrix(A))
        - 
        - """
        -     preimage(A::AbstractArray[, vs::VectorSpace] [, k::Int=1])
        - 
        - Create vector space, which is the inverse image of `vs` under the mapping `A^k`.
        - `vs` defaults to the zero space; in that case the kernel of `A^k` is returned.
        - """
        1 preimage(A::AbstractArray{T}) where {T<:Number} = kernel(A)
        - function preimage(A::AbstractArray{T}, k::Int) where {T<:Number}
        -     k == 1 ? kernel(A) : preimage(A, ZeroSpace(T, size(A, 1)), k)
        - end
        - 
        - function preimage(A::AbstractArray, vs::VectorSpace, k::Int=1)
        -     k ≥ 0 || error("exponent ≥ 0 required")
        -     n, m = size(A)
        -     na, ra = size(vs)
        -     n == m || k == 1 || error("exponent k ≠ 1 only for square matrix")
        -     na == n || error("matrix dimension 1 does not match target space dimension")
        - 
        -     va = vs
        -     if k > 0
        -         va = ra == 0 ? kernel(A) : A \ va
        -         rp = 0
        -         r = va.rank
        -         while k > 1 && r > rp
        -             vaa = A \ va
        -             rp = r
        -             r = rank(vaa)
        -             k -= 1
        -             if r > rp
        -                 va = vaa
        -             end
        -         end
        -     end
        -     va
        - end
        - 
        - """
        -     union(va::VectorSpace, vb::VectorSpace) -> VectorSpace
        - 
        - Create VectorSpace representing `va ∪ vb`. VectorSpace
        - """
        2 function union(va::VectorSpace, vb::VectorSpace)
        2     na, ra = size(va)
        2     nb, rb = size(vb)
        2     na == nb || error("dimension mismatch")
        - 
        4     if ra >= na || rb >= nb
        0         VectorSpace{eltype(va)}(va.na)
        2     elseif ra == 0
        0         vb
        2     elseif rb == 0
        0         va
        -     else
        2         A = [span(va) span(vb)]
        2         VectorSpace(A)
        -     end
        - end
        - 
        - """
        -     intersect(va::VectorSpace, vb::VectorSpace) -> VectorSpace
        - 
        - Create VectorSpace representing `va ∩ vb`.
        - """
        2 function intersect(va::VectorSpace, vb::VectorSpace)
        2     na, ra = size(va)
        2     nb, rb = size(vb)
        2     na == nb || error("dimension mismatch")
        - 
        4     if ra == 0 || rb == 0
        0         ZeroSpace(typeof(va), va.na)
        2     elseif ra == na
        0         vb
        2     elseif rb == nb
        0         va
        -     else
        2         U = span(va)
        2         V = span(vb)
        2         K = kernel_matrix([U -V])
        2         VectorSpace(U * K[1:rank(va), :])
        -     end
        - end
        - 
        - """
        -     in(A::AbstractArray, vb::VectorSpace) -> Bool
        - 
        - Determine if `A[:,k] ∈ vb ∀ k`.
        - """
        - function Base.in(A::AbstractArray, vs::VectorSpace)
        -     issubset(VectorSpace(A), vs)
        - end
        - 
        - """
        -     issubset(va::VectorSpace, vb::VectorSpace) -> Bool
        - 
        - Determine if `va ⊆ vb`.
        - """
       15 function Base.issubset(va::VectorSpace{T}, vb::VectorSpace{T}) where {T<:Number}
       15     na, ra = size(va)
       15     nb, rb = size(vb)
       15     na == nb || error("vector spaces not in same base space")
        - 
       25     rb >= nb || ra <= 0 && return true
       10     ra > rb && return false
       20     spanba = span_adjoint(vb)' * span(va)
       10     norm(vec(spanba), Inf) <= 4eps(T) * na
        - end
        - 
        - """
        - 
        -     va == vb
        - 
        - Determine if VectorSpaces are (numerically) equal.
        - Equivalent to `va ⊆ vb and vb ⊆ va`.
        - """
       13 function ==(va::VectorSpace, vb::VectorSpace)
       13     va.rank == vb.rank &&
        -         issubset(va, vb)
        - end
        - 
        - #########################################################################################
        - 
       22 function _rank(QR::LinearAlgebra.QRPivoted{T,S}, tol::AbstractFloat) where {S<:AbstractMatrix{T}} where {T<:Number}
       22     minimum(size(QR)) == 0 && (return 0)
       22     R = QR.R
       44     sv = sort(abs.(diag(R)), rev=true)
       22     n = length(sv)
       26     while n > 0 && sv[n] <= tol
        4         n -= 1
        4     end
       22     n
        - end
        - 
        - """
        -     tolerance(A::AbstractMatrix)
        - 
        - Return standard tolerance for a matrix.
        - """
       44 @inline tolerance(A::AbstractMatrix) = eps(norm(A, 1)) * maximum(size(A))
        - 
        - """
        -     kernel_matrix(A::AbstractMatrix) -> Matrix
        - 
        - Produce unitary matrix, whose vectors are basis of the kernel of Matrix A.
        - If the matrix is injective, the a matrix with zero columns is returned.
        - If the matrix has rank zero, the unit matrix is returned.
        - """
        9 function kernel_matrix(A::AbstractMatrix{T}) where {T<:Number}
        - 
       18     tol = tolerance(A)
        9     QR = qr(A, ColumnNorm())
        9     r = _rank(QR, tol)
        9     n, m = size(A)
       51     K = zeros(T, m, m - r)
       11     for k = r+1:m
        6         K[k, k-r] = one(T)
       10     end
        9     if 0 < r < m
        2         r1r = 1:r
        2         rrm = r+1:m
        2         R = QR.R
        2         RV = view(R, r1r, r1r)
        2         K[r1r, :] = -RV \ R[r1r, rrm]
        2         p = invperm(QR.p)
        3         K = Matrix(qr(K[p, :]).Q)
        -     end
        9     K
        - end
        - 
        - function kernel_matrix(A::AbstractVector{T}) where {T<:Number}
        -     kernel_matrix(reshape(A, size(A, 1), 1))
        - end
        - 
        - end # module
